<!DOCTYPE html>
<html>
<head>
    <title>Three.js Fluid Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- lil-gui will be injected here -->

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.js"
            }
        }
    </script>

    <!-- Vertex Shader (used for all passes) -->
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>

    <!-- Advection Shader -->
    <script id="advectionShader" type="x-shader/x-fragment">
        uniform sampler2D u_velocity;
        uniform sampler2D u_source; // The quantity being advected (e.g., velocity itself, or color)
        uniform vec2 u_resolution;
        uniform float u_dt; // Delta time
        varying vec2 vUv;

        void main() {
            vec2 px = 1.0 / u_resolution;
            // Backtrace to find the source point
            vec2 vel = texture2D(u_velocity, vUv).xy;
            vec2 prev_pos = vUv - u_dt * vel * px; // Go backwards along velocity vector
            
            // Sample the source at the backtraced position
            gl_FragColor = texture2D(u_source, prev_pos);
        }
    </script>
    
    <!-- Divergence Shader -->
    <script id="divergenceShader" type="x-shader/x-fragment">
        uniform sampler2D u_velocity;
        uniform vec2 u_resolution;
        varying vec2 vUv;

        void main() {
            vec2 px = 1.0 / u_resolution;
            // Sample velocity at neighbors to calculate divergence
            float v_l = texture2D(u_velocity, vUv - vec2(px.x, 0.0)).x;
            float v_r = texture2D(u_velocity, vUv + vec2(px.x, 0.0)).x;
            float v_b = texture2D(u_velocity, vUv - vec2(0.0, px.y)).y;
            float v_t = texture2D(u_velocity, vUv + vec2(0.0, px.y)).y;
            
            // Calculate divergence (del . v)
            float divergence = 0.5 * ((v_r - v_l) + (v_t - v_b));
            gl_FragColor = vec4(divergence, 0.0, 0.0, 1.0); // Store divergence in red channel
        }
    </script>

    <!-- Pressure (Jacobi Iteration) Shader -->
    <script id="pressureShader" type="x-shader/x-fragment">
        uniform sampler2D u_pressure;
        uniform sampler2D u_divergence;
        uniform vec2 u_resolution;
        varying vec2 vUv;
        
        void main() {
            vec2 px = 1.0 / u_resolution;
            // Sample pressure from neighbors
            float p_l = texture2D(u_pressure, vUv - vec2(px.x, 0.0)).r;
            float p_r = texture2D(u_pressure, vUv + vec2(px.x, 0.0)).r;
            float p_b = texture2D(u_pressure, vUv - vec2(0.0, px.y)).r;
            float p_t = texture2D(u_pressure, vUv + vec2(0.0, px.y)).r;
            float div = texture2D(u_divergence, vUv).r;

            // Jacobi iteration for Poisson equation (del^2 P = del . V)
            // P_new = 0.25 * (P_left + P_right + P_bottom + P_top - divergence)
            float new_p = (p_l + p_r + p_b + p_t - div) * 0.25;
            gl_FragColor = vec4(new_p, 0.0, 0.0, 1.0);
        }
    </script>
    
    <!-- Gradient Subtraction Shader -->
    <script id="gradientSubtractShader" type="x-shader/x-fragment">
        uniform sampler2D u_velocity;
        uniform sampler2D u_pressure;
        uniform vec2 u_resolution;
        varying vec2 vUv;

        void main() {
            vec2 px = 1.0 / u_resolution;
            // Sample pressure from neighbors to calculate gradient
            float p_l = texture2D(u_pressure, vUv - vec2(px.x, 0.0)).r;
            float p_r = texture2D(u_pressure, vUv + vec2(px.x, 0.0)).r;
            float p_b = texture2D(u_pressure, vUv - vec2(0.0, px.y)).r;
            float p_t = texture2D(u_pressure, vUv + vec2(0.0, px.y)).r;

            // Calculate pressure gradient (del P)
            vec2 grad_p = 0.5 * vec2(p_r - p_l, p_t - p_b);
            vec2 vel = texture2D(u_velocity, vUv).xy;
            
            // Subtract pressure gradient from velocity
            gl_FragColor = vec4(vel - grad_p, 0.0, 1.0);
        }
    </script>

    <!-- Add Force Shader -->
    <script id="addForceShader" type="x-shader/x-fragment">
        uniform sampler2D u_velocity;
        uniform vec2 u_mouse_pos;      // Mouse position in simulation grid coordinates
        uniform vec2 u_mouse_velocity; // Velocity vector from mouse drag
        uniform float u_radius;        // Radius of the force application
        uniform vec2 u_resolution;
        varying vec2 vUv;
        
        void main() {
            vec2 old_vel = texture2D(u_velocity, vUv).xy;
            // Calculate distance from mouse position
            float dist = distance(vUv * u_resolution, u_mouse_pos);
            // Apply a smooth falloff for the force
            float intensity = 1.0 - smoothstep(0.0, u_radius, dist);
            
            // Mix the old velocity with the mouse velocity for a drag effect
            vec2 new_vel = mix(old_vel, old_vel + u_mouse_velocity, intensity);
            gl_FragColor = vec4(new_vel, 0.0, 1.0);
        }
    </script>

     <!-- Splat (Add Color) Shader -->
    <script id="splatShader" type="x-shader/x-fragment">
        uniform sampler2D u_target; // The dye texture
        uniform vec2 u_mouse_pos;
        uniform float u_radius;
        uniform vec3 u_color;
        uniform vec2 u_resolution;
        varying vec2 vUv;
        
        void main() {
            vec4 old_value = texture2D(u_target, vUv);
            float dist = distance(vUv * u_resolution, u_mouse_pos);
            float intensity = smoothstep(u_radius, 0.0, dist);
            
            // Add the new color, weighted by intensity
            old_value.rgb += u_color * intensity;
            
            gl_FragColor = old_value;
        }
    </script>
    
    <!-- Decay Shader -->
    <script id="decayShader" type="x-shader/x-fragment">
        uniform sampler2D u_velocity;
        uniform float u_decay;
        varying vec2 vUv;

        void main() {
            vec4 vel = texture2D(u_velocity, vUv);
            vel.xy *= u_decay; // Apply decay to x and y components
            gl_FragColor = vel;
        }
    </script>

    <!-- Dissipation Shader -->
    <script id="dissipationShader" type="x-shader/x-fragment">
        uniform sampler2D u_dye;
        uniform float u_dissipation;
        varying vec2 vUv;

        void main() {
            vec4 color = texture2D(u_dye, vUv);
            color.rgb *= u_dissipation; // Apply dissipation to rgb components
            gl_FragColor = color;
        }
    </script>

    <!-- Vorticity (Curl) Shader -->
    <script id="vorticityShader" type="x-shader/x-fragment">
        uniform sampler2D u_velocity;
        uniform vec2 u_resolution;
        varying vec2 vUv;

        void main() {
            vec2 px = 1.0 / u_resolution;
            // Sample neighboring velocities
            float v_l = texture2D(u_velocity, vUv - vec2(px.x, 0.0)).y;
            float v_r = texture2D(u_velocity, vUv + vec2(px.x, 0.0)).y;
            float v_b = texture2D(u_velocity, vUv - vec2(0.0, px.y)).x;
            float v_t = texture2D(u_velocity, vUv + vec2(0.0, px.y)).x;
            
            // Calculate curl (d(Vy)/dx - d(Vx)/dy)
            float curl = 0.5 * ((v_r - v_l) - (v_t - v_b));
            gl_FragColor = vec4(curl, 0.0, 0.0, 1.0);
        }
    </script>

    <!-- Vorticity Confinement Shader -->
    <script id="vorticityConfinementShader" type="x-shader/x-fragment">
        uniform sampler2D u_velocity;
        uniform sampler2D u_vorticity;
        uniform vec2 u_resolution;
        uniform float u_vorticity_amount;
        uniform float u_dt;
        varying vec2 vUv;

        void main() {
            vec2 px = 1.0 / u_resolution;
            // Sample neighboring vorticity values to find the gradient
            float c_l = texture2D(u_vorticity, vUv - vec2(px.x, 0.0)).r;
            float c_r = texture2D(u_vorticity, vUv + vec2(px.x, 0.0)).r;
            float c_b = texture2D(u_vorticity, vUv - vec2(0.0, px.y)).r;
            float c_t = texture2D(u_vorticity, vUv + vec2(0.0, px.y)).r;
            
            // Calculate gradient of vorticity
            vec2 grad = 0.5 * vec2(c_r - c_l, c_t - c_b);
            
            // Normalize gradient to get the direction of confinement force
            vec2 N = normalize(grad + 1e-6); // Add small epsilon to avoid division by zero
            
            float curl = texture2D(u_vorticity, vUv).r;
            
            // Calculate confinement force (perpendicular to gradient)
            vec2 force = u_vorticity_amount * curl * vec2(N.y, -N.x);
            
            vec2 old_vel = texture2D(u_velocity, vUv).xy;
            // Add force to velocity
            vec2 new_vel = old_vel + force * u_dt;
            gl_FragColor = vec4(new_vel, 0.0, 1.0);
        }
    </script>

    <!-- Visualization Shader -->
    <script id="visualizeShader" type="x-shader/x-fragment">
        uniform sampler2D u_dye;
        varying vec2 vUv;
        
        void main() {
            gl_FragColor = texture2D(u_dye, vUv);
        }
    </script>


    <script type="module">
        import * as THREE from 'three';
        import GUI from 'lil-gui';

        // --- Simulation Parameters ---
        const default_colors = {
            mouse: { r: 0.2, g: 0.5, b: 1.0 },
            touches: [
                { r: 1.0, g: 0.1, b: 0.1 }, // Red
                { r: 0.1, g: 1.0, b: 0.1 }, // Green
                { r: 0.1, g: 0.5, b: 1.0 }, // Blue
                { r: 1.0, g: 1.0, b: 0.1 }, // Yellow
                { r: 1.0, g: 0.1, b: 1.0 }, // Magenta
            ]
        };
        
        const sim_params = {
            resolution: 512,
            dt: 0.035,
            pressure_iterations: 50,
            force_radius: 42.0,
            decay: 0.99,
            vorticity: 0.2,
            dissipation: 0.991,
            mouse_color: { ...default_colors.mouse },
            touch_colors: default_colors.touches.map(c => ({...c})),
        };

        // --- Basic Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1); // Fullscreen quad camera
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Adjust height to maintain aspect ratio with the display window
        let grid_width = sim_params.resolution;
        let grid_height = Math.floor(sim_params.resolution * (window.innerHeight / window.innerWidth));
        
        // --- Render Targets (FBOs) ---
        // These are used to store intermediate calculation results on the GPU
        const rt_options = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            type: THREE.FloatType, // Crucial for precision in fluid simulations
            format: THREE.RGBAFormat,
            stencilBuffer: false,
            depthBuffer: false,
        };
        // Two render targets for velocity, pressure, and dye for ping-ponging
        let velocity_rt_1 = new THREE.WebGLRenderTarget(grid_width, grid_height, rt_options);
        let velocity_rt_2 = new THREE.WebGLRenderTarget(grid_width, grid_height, rt_options);
        let pressure_rt_1 = new THREE.WebGLRenderTarget(grid_width, grid_height, rt_options);
        let pressure_rt_2 = new THREE.WebGLRenderTarget(grid_width, grid_height, rt_options);
        let dye_rt_1 = new THREE.WebGLRenderTarget(grid_width, grid_height, rt_options);
        let dye_rt_2 = new THREE.WebGLRenderTarget(grid_width, grid_height, rt_options);
        // One for divergence, one for vorticity
        let divergence_rt = new THREE.WebGLRenderTarget(grid_width, grid_height, rt_options);
        let vorticity_rt = new THREE.WebGLRenderTarget(grid_width, grid_height, rt_options);


        // Clear all buffers to start in a known clean state
        function clearAllRenderTargets() {
            renderer.setRenderTarget(velocity_rt_1); renderer.clear();
            renderer.setRenderTarget(velocity_rt_2); renderer.clear();
            renderer.setRenderTarget(pressure_rt_1); renderer.clear();
            renderer.setRenderTarget(pressure_rt_2); renderer.clear();
            renderer.setRenderTarget(dye_rt_1); renderer.clear();
            renderer.setRenderTarget(dye_rt_2); renderer.clear();
            renderer.setRenderTarget(divergence_rt); renderer.clear();
            renderer.setRenderTarget(vorticity_rt); renderer.clear();
            renderer.setRenderTarget(null);
        }
        clearAllRenderTargets(); // Clear on initialization

        // --- Geometry for fullscreen quad ---
        const quad_geometry = new THREE.PlaneGeometry(2, 2); // A plane covering the entire screen

        // --- Materials & Shaders ---
        // Each simulation step will have its own ShaderMaterial
        const vertexShader = document.getElementById('vertexShader').textContent;

        const advection_material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader: document.getElementById('advectionShader').textContent,
            uniforms: {
                u_velocity: { value: null },
                u_source: { value: null },
                u_resolution: { value: new THREE.Vector2(grid_width, grid_height) },
                u_dt: { value: sim_params.dt },
            }
        });

        const divergence_material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader: document.getElementById('divergenceShader').textContent,
            uniforms: {
                u_velocity: { value: null },
                u_resolution: { value: new THREE.Vector2(grid_width, grid_height) },
            }
        });
        
        const pressure_material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader: document.getElementById('pressureShader').textContent,
            uniforms: {
                u_pressure: { value: null },
                u_divergence: { value: null },
                u_resolution: { value: new THREE.Vector2(grid_width, grid_height) },
            }
        });

        const gradient_subtract_material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader: document.getElementById('gradientSubtractShader').textContent,
            uniforms: {
                u_velocity: { value: null },
                u_pressure: { value: null },
                u_resolution: { value: new THREE.Vector2(grid_width, grid_height) },
            }
        });

        const add_force_material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader: document.getElementById('addForceShader').textContent,
            uniforms: {
                u_velocity: { value: null },
                u_mouse_pos: { value: new THREE.Vector2(0, 0) },
                u_mouse_velocity: { value: new THREE.Vector2(0, 0) },
                u_radius: { value: sim_params.force_radius },
                u_resolution: { value: new THREE.Vector2(grid_width, grid_height) },
            }
        });
        
        const splat_material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader: document.getElementById('splatShader').textContent,
            uniforms: {
                u_target: { value: null },
                u_mouse_pos: { value: new THREE.Vector2(0, 0) },
                u_radius: { value: sim_params.force_radius },
                u_color: { value: new THREE.Color() }, // Color is set per-pointer
                u_resolution: { value: new THREE.Vector2(grid_width, grid_height) },
            }
        });

        const decay_material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader: document.getElementById('decayShader').textContent,
            uniforms: {
                u_velocity: { value: null },
                u_decay: { value: sim_params.decay },
            }
        });

        const dissipation_material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader: document.getElementById('dissipationShader').textContent,
            uniforms: {
                u_dye: { value: null },
                u_dissipation: { value: sim_params.dissipation },
            }
        });
        
        const vorticity_material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader: document.getElementById('vorticityShader').textContent,
            uniforms: {
                u_velocity: { value: null },
                u_resolution: { value: new THREE.Vector2(grid_width, grid_height) },
            }
        });

        const vorticity_confinement_material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader: document.getElementById('vorticityConfinementShader').textContent,
            uniforms: {
                u_velocity: { value: null },
                u_vorticity: { value: null },
                u_resolution: { value: new THREE.Vector2(grid_width, grid_height) },
                u_vorticity_amount: { value: sim_params.vorticity },
                u_dt: { value: sim_params.dt },
            }
        });

        const visualize_material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader: document.getElementById('visualizeShader').textContent,
            uniforms: {
                u_dye: { value: null }
            }
        });
        
        // The mesh uses a null material initially, as it will be set dynamically
        const quad_mesh = new THREE.Mesh(quad_geometry, null);
        scene.add(quad_mesh);

        // --- UI Controls ---
        const gui = new GUI();

        function updateResolution() {
            // Update grid dimensions
            grid_width = sim_params.resolution;
            grid_height = Math.floor(sim_params.resolution * (window.innerHeight / window.innerWidth));

            // Resize all render targets
            velocity_rt_1.setSize(grid_width, grid_height);
            velocity_rt_2.setSize(grid_width, grid_height);
            pressure_rt_1.setSize(grid_width, grid_height);
            pressure_rt_2.setSize(grid_width, grid_height);
            dye_rt_1.setSize(grid_width, grid_height);
            dye_rt_2.setSize(grid_width, grid_height);
            divergence_rt.setSize(grid_width, grid_height);
            vorticity_rt.setSize(grid_width, grid_height);

            // Update resolution uniforms in all materials
            const newResolution = new THREE.Vector2(grid_width, grid_height);
            advection_material.uniforms.u_resolution.value = newResolution;
            divergence_material.uniforms.u_resolution.value = newResolution;
            pressure_material.uniforms.u_resolution.value = newResolution;
            gradient_subtract_material.uniforms.u_resolution.value = newResolution;
            add_force_material.uniforms.u_resolution.value = newResolution;
            splat_material.uniforms.u_resolution.value = newResolution;
            vorticity_material.uniforms.u_resolution.value = newResolution;
            vorticity_confinement_material.uniforms.u_resolution.value = newResolution;

            // Clear everything to reset the simulation state
            clearAllRenderTargets();
        }

        function refreshGUI() {
            gui.controllers.forEach(c => c.updateDisplay());
            gui.folders.forEach(folder => {
                folder.controllers.forEach(c => c.updateDisplay());
            });
        }

        function resetSimulation() {
            clearAllRenderTargets();
            // Reset params to defaults
            sim_params.dt = 0.035;
            sim_params.pressure_iterations = 50;
            sim_params.force_radius = 42.0;
            sim_params.decay = 0.99;
            sim_params.vorticity = 0.2;
            sim_params.dissipation = 0.991;
            
            // Reset colors
            Object.assign(sim_params.mouse_color, default_colors.mouse);
            sim_params.touch_colors.forEach((_, i) => {
                Object.assign(sim_params.touch_colors[i], default_colors.touches[i]);
            });

            // Manually update shader uniforms
            advection_material.uniforms.u_dt.value = sim_params.dt;
            vorticity_confinement_material.uniforms.u_dt.value = sim_params.dt;
            add_force_material.uniforms.u_radius.value = sim_params.force_radius;
            splat_material.uniforms.u_radius.value = sim_params.force_radius;
            decay_material.uniforms.u_decay.value = sim_params.decay;
            dissipation_material.uniforms.u_dissipation.value = sim_params.dissipation;
            vorticity_confinement_material.uniforms.u_vorticity_amount.value = sim_params.vorticity;
            
            refreshGUI();
        }

        gui.add(sim_params, 'resolution', [128, 256, 512, 1024]).name('Resolution').onChange(updateResolution);
        gui.add(sim_params, 'dt', 0.001, 0.032, 0.001).name('Delta Time').onChange(value => {
            advection_material.uniforms.u_dt.value = value;
            vorticity_confinement_material.uniforms.u_dt.value = value;
        });
        gui.add(sim_params, 'pressure_iterations', 5, 50, 1).name('Pressure Iterations');
        gui.add(sim_params, 'force_radius', 1, 100, 1).name('Force Radius').onChange(value => {
            add_force_material.uniforms.u_radius.value = value;
            splat_material.uniforms.u_radius.value = value;
        });
        gui.add(sim_params, 'decay', 0.5, 1.0, 0.001).name('Velocity Decay').onChange(value => {
            decay_material.uniforms.u_decay.value = value;
        });
        gui.add(sim_params, 'dissipation', 0.9, 1.0, 0.001).name('Dissipation').onChange(value => {
            dissipation_material.uniforms.u_dissipation.value = value;
        });
        gui.add(sim_params, 'vorticity', 0, 4, 0.01).name('Vorticity').onChange(value => {
            vorticity_confinement_material.uniforms.u_vorticity_amount.value = value;
        });
        
        gui.addColor(sim_params, 'mouse_color').name('Mouse Color');
        
        const touch_colors_folder = gui.addFolder('Touch Colors');
        for (let i = 0; i < sim_params.touch_colors.length; i++) {
            touch_colors_folder.addColor(sim_params.touch_colors, i).name(`Touch Color ${i + 1}`);
        }

        gui.add({ reset: resetSimulation }, 'reset').name('Reset Simulation');


        // --- Pointer Interaction (Mouse & Touch) ---
        const pointers = new Map();
        let next_touch_color_index = 0;

        // Mouse Listeners
        window.addEventListener('mousedown', (e) => {
            let pointer = pointers.get('mouse');
            if (!pointer) {
                pointer = {
                    pos: new THREE.Vector2(0, 0),
                    prev_pos: new THREE.Vector2(0, 0),
                    force: new THREE.Vector2(0, 0),
                    color: new THREE.Color(),
                };
                pointers.set('mouse', pointer);
            }
            pointer.down = true;
            pointer.pos.set(e.clientX, window.innerHeight - e.clientY);
            pointer.prev_pos.copy(pointer.pos);
            const guiColor = sim_params.mouse_color;
            pointer.color.setRGB(guiColor.r, guiColor.g, guiColor.b);
        });

        window.addEventListener('mousemove', (e) => {
            const pointer = pointers.get('mouse');
            if (pointer && pointer.down) {
                pointer.pos.set(e.clientX, window.innerHeight - e.clientY);
            }
        });

        window.addEventListener('mouseup', () => {
            const pointer = pointers.get('mouse');
            if (pointer) {
                pointer.down = false;
            }
        });

        // Touch Listeners
        function handleTouchEvent(e, isEndEvent) {
            // Prevent default browser actions like scrolling, but only if the touch is not on the GUI.
            if (!e.target.closest('.lil-gui')) {
                e.preventDefault();
            }

            for (const touch of e.changedTouches) {
                const id = touch.identifier;
                if (isEndEvent) {
                    pointers.delete(id);
                    continue;
                }
                let pointer = pointers.get(id);
                if (!pointer) { // New touch
                    pointer = {
                        pos: new THREE.Vector2(0, 0),
                        prev_pos: new THREE.Vector2(0, 0),
                        force: new THREE.Vector2(0, 0),
                        color: new THREE.Color(),
                        down: true,
                    };
                    const color_obj = sim_params.touch_colors[next_touch_color_index];
                    pointer.color.setRGB(color_obj.r, color_obj.g, color_obj.b);
                    next_touch_color_index = (next_touch_color_index + 1) % sim_params.touch_colors.length;
                    pointers.set(id, pointer);
                }
                pointer.pos.set(touch.clientX, window.innerHeight - touch.clientY);
                if (e.type === 'touchstart') {
                    pointer.prev_pos.copy(pointer.pos);
                }
            }
        }

        window.addEventListener('touchstart', (e) => handleTouchEvent(e, false), { passive: false });
        window.addEventListener('touchmove', (e) => handleTouchEvent(e, false), { passive: false });
        window.addEventListener('touchend', (e) => handleTouchEvent(e, true), { passive: false });
        window.addEventListener('touchcancel', (e) => handleTouchEvent(e, true), { passive: false });


        // --- Render Pass Function ---
        // Helper to perform a single simulation step (render a shader to a render target)
        function renderPass(material, output_rt) {
            quad_mesh.material = material;
            renderer.setRenderTarget(output_rt);
            renderer.render(scene, camera);
            renderer.setRenderTarget(null); // Render back to screen
        }
        
        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            // 1. Add Forces & Colors from all active pointers
            pointers.forEach((pointer) => {
                if (pointer.down) {
                    pointer.force.subVectors(pointer.pos, pointer.prev_pos);
                    pointer.prev_pos.copy(pointer.pos);

                    const pointer_grid_pos = new THREE.Vector2(
                        pointer.pos.x * (grid_width / window.innerWidth), 
                        pointer.pos.y * (grid_height / window.innerHeight)
                    );

                    // Add force to velocity field
                    add_force_material.uniforms.u_velocity.value = velocity_rt_1.texture;
                    add_force_material.uniforms.u_mouse_pos.value = pointer_grid_pos;
                    add_force_material.uniforms.u_mouse_velocity.value = pointer.force;
                    renderPass(add_force_material, velocity_rt_2);
                    [velocity_rt_1, velocity_rt_2] = [velocity_rt_2, velocity_rt_1];

                    // Add color to dye field
                    splat_material.uniforms.u_target.value = dye_rt_1.texture;
                    splat_material.uniforms.u_mouse_pos.value = pointer_grid_pos;
                    splat_material.uniforms.u_color.value = pointer.color;
                    renderPass(splat_material, dye_rt_2);
                    [dye_rt_1, dye_rt_2] = [dye_rt_2, dye_rt_1];
                }
            });

            // 2. Advection (move velocity along itself)
            advection_material.uniforms.u_velocity.value = velocity_rt_1.texture;
            advection_material.uniforms.u_source.value = velocity_rt_1.texture; // Advecting velocity
            renderPass(advection_material, velocity_rt_2);
            [velocity_rt_1, velocity_rt_2] = [velocity_rt_2, velocity_rt_1]; // Swap

            // Advect dye along velocity field
            advection_material.uniforms.u_source.value = dye_rt_1.texture; // Advecting dye
            renderPass(advection_material, dye_rt_2);
            [dye_rt_1, dye_rt_2] = [dye_rt_2, dye_rt_1]; // Swap

            // 3. Apply Velocity Decay & Color Dissipation
            decay_material.uniforms.u_velocity.value = velocity_rt_1.texture;
            renderPass(decay_material, velocity_rt_2);
            [velocity_rt_1, velocity_rt_2] = [velocity_rt_2, velocity_rt_1]; // Swap

            dissipation_material.uniforms.u_dye.value = dye_rt_1.texture;
            renderPass(dissipation_material, dye_rt_2);
            [dye_rt_1, dye_rt_2] = [dye_rt_2, dye_rt_1]; // Swap

            // 4. Calculate Vorticity (Curl)
            vorticity_material.uniforms.u_velocity.value = velocity_rt_1.texture;
            renderPass(vorticity_material, vorticity_rt);
            
            // 5. Apply Vorticity Confinement Force
            vorticity_confinement_material.uniforms.u_velocity.value = velocity_rt_1.texture;
            vorticity_confinement_material.uniforms.u_vorticity.value = vorticity_rt.texture;
            renderPass(vorticity_confinement_material, velocity_rt_2);
            [velocity_rt_1, velocity_rt_2] = [velocity_rt_2, velocity_rt_1]; // Swap

            // 6. Calculate Divergence
            divergence_material.uniforms.u_velocity.value = velocity_rt_1.texture;
            renderPass(divergence_material, divergence_rt);
            
            // 7. Pressure Projection (Jacobi iterations to solve Poisson equation)
            pressure_material.uniforms.u_divergence.value = divergence_rt.texture;
            // Clear pressure buffer before iterations
            renderer.setRenderTarget(pressure_rt_1); renderer.clear();
            renderer.setRenderTarget(pressure_rt_2); renderer.clear();

            for (let i = 0; i < sim_params.pressure_iterations; i++) {
                pressure_material.uniforms.u_pressure.value = pressure_rt_1.texture;
                renderPass(pressure_material, pressure_rt_2);
                [pressure_rt_1, pressure_rt_2] = [pressure_rt_2, pressure_rt_1]; // Swap
            }

            // 8. Subtract Pressure Gradient from velocity
            gradient_subtract_material.uniforms.u_velocity.value = velocity_rt_1.texture;
            gradient_subtract_material.uniforms.u_pressure.value = pressure_rt_1.texture;
            renderPass(gradient_subtract_material, velocity_rt_2);
            [velocity_rt_1, velocity_rt_2] = [velocity_rt_2, velocity_rt_1]; // Swap
            
            // 9. Visualize the final dye field
            visualize_material.uniforms.u_dye.value = dye_rt_1.texture;
            quad_mesh.material = visualize_material;
            renderer.render(scene, camera);
        }

        animate();
        
        // Handle window resizing
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            const new_grid_height = Math.floor(sim_params.resolution * (window.innerHeight / window.innerWidth));
            grid_height = new_grid_height;

            // Resize all render targets and update resolution uniforms
            velocity_rt_1.setSize(grid_width, new_grid_height);
            velocity_rt_2.setSize(grid_width, new_grid_height);
            pressure_rt_1.setSize(grid_width, new_grid_height);
            pressure_rt_2.setSize(grid_width, new_grid_height);
            dye_rt_1.setSize(grid_width, new_grid_height);
            dye_rt_2.setSize(grid_width, new_grid_height);
            divergence_rt.setSize(grid_width, new_grid_height);
            vorticity_rt.setSize(grid_width, new_grid_height);

            const newResolution = new THREE.Vector2(grid_width, new_grid_height);
            advection_material.uniforms.u_resolution.value = newResolution;
            divergence_material.uniforms.u_resolution.value = newResolution;
            pressure_material.uniforms.u_resolution.value = newResolution;
            gradient_subtract_material.uniforms.u_resolution.value = newResolution;
            add_force_material.uniforms.u_resolution.value = newResolution;
            splat_material.uniforms.u_resolution.value = newResolution;
            vorticity_material.uniforms.u_resolution.value = newResolution;
            vorticity_confinement_material.uniforms.u_resolution.value = newResolution;
        });

    </script>
</body>
</html>